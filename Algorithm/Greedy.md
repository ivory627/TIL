# 탐욕법(Greedy Algorithm)

> 그리디 알고리즘이란?
>
> 매 선택에서 지금 이 순간 당장 최적인 답을 선택하여 적합한 결과를 도출하는 알고리즘이다.
>
> 단, 매 선택이 그 순간에 대해서는 최적이지만 최종적인 결과로 보았을 땐 최적이라는 보장은 없다.

![greedy](https://user-images.githubusercontent.com/58761162/92551123-349ee200-f298-11ea-897b-9b6485cbc90a.png)

예를들어 다음은 그리디 알고리즘으로 가장 큰 수를 찾아내는 것인데,

보시다시피 매 순간 큰 수를 선택하여 최종적으로 얻은 결과는 12이다.

하지만 실제로 가장 큰 수는 99임을 알 수 있다.

이처럼 매 순간 최적해를 선택하는 알고리즘이지만 최종적으로 보았을 땐 최적해가 아닐 수 있다는 것이다.

그럴 땐 다이나믹 프로그래밍 등의 기타 알고리즘 기법을 적용해야한다.



#### 알고리즘

1. 해 선택 (Selection Procedure) : 지금 당시 가장 최적인 해를 구한 뒤, 이를 부분해 집합에 추가
2. 적절성 검사 (Feasibility Check) : 새로운 부분해 집합이 적절한지 검사
3. 해 검사(Solution Check) : 새로운 부분해 집합이 문제의 해가 되는지 검사. 아직 문제의 해가 완성되지 않았다면 1번부터 다시 시작



#### 그리디 알고리즘 활용 문제

- 최소 수의 동전으로 거스름돈 거슬러주기

  1. 해 선택 : 가장 가치가 높은 동전을 우선으로 선택하면 동전의 갯수를 적게 거슬러줄 수 있다. 가장 가치가 높은 동전을 골라서 부분해 집합에 추가한다.
  2. 적절성 검사 : 부분해 집합이 거슬러 줄 금액을 초과하는지 검사한다. 초과한다면 가장 최근에 추가한 동전을 삭제하고 1번으로 돌아가 현재보다 한 단계 낮은 가치의 동전을 추가한다.
  3. 해 검사 : 부분해 집합이 거슬러 줄 금액과 일치하는지 검사한다. 액수가 모자라면 다시 1번으로 돌아가서 부분해 집합에 추가한 동전을 고른다.

  ```java
  import java.util.ArrayList;
  import java.util.List;
  
  public class CoinChange {
  
  	public static void main(String[] args) {
  
          int remain = 750;
          int coins[] = { 10, 50, 100, 500, 1000 };
          List<Integer> result = coinChangeAlgorithm(coins, remain);
          System.out.println(result);
  	}
  	
  	public static List<Integer> coinChangeAlgorithm(int coins[], int remain) {
  		 
          // 1.선택한 동전의 결과를 저장할 배열을 초기화 한다.
          List<Integer> result = new ArrayList<>();
   
   
          for(int i = coins.length - 1; i >= 0 ; i--) {
              // 2. 거슬러 줄 돈보다 작은 동전중에서 가장 큰 동전을 찾는다.
              while(coins[i] <= remain) {
                  result.add(coins[i]);
                  remain -= coins[i];
                  if(remain == 0) {
                      break;
                  }
              }
          }
   
          return result;
      }
  
  }
  ```

  이러한 CoinChange알고리즘이 현재 우리나라 동전 시스템은

  100,50,10이 500의 약수이고 50,10이 100의 약수, 10이 50의 약수이므로 항상 최소의 동전 수로 거스름돈으로 계산된다.

  만일 [10,50,100,140] 단위의 동전이 있고 200원을 거슬러주어야한다면

  그리디 알고리즘으로 적용했을때 140원 1개, 50원 1개, 10원 1개로 총 3개로 거슬러주어야한다.

  하지만 최소 동전 수는 100원 2개이다. 따라서 항상 최적해를 보장할 수 없는 것이다.

  

- 최소비용 신장트리

  > 그래프 내의 모든 정점을 최소의 비용으로 연결하는 트리
  >
  > ex ) 프림 알고리즘, 크루스칼 알고리즘

  크루스칼 알고리즘

  1. 그래프 내의 모든 간선을 가중치의 오름차순으로 목록을 만든다.
  2. 1번에서 만든 간선의 목록을 차례대로 순회하면서 간선을 최소비용 신장트리에 추가한다. 단, 이때 추가된 간선으로 인해 트리구조가 망가지면 안된다. (사이클이 생기면 안된다.)

  여기서 탐욕법이 활용되는 부분은 2번이다.

  이 부분에서 '해 선택 - 적절성 검사 - 해 검사'의 반복이 이루어진다.

  해 검사는 부분해 집합이 하나가 되면 최적해로 판단한다.

  
  
- 다익스트라 알고리즘

  > 그래프 내의 한 정점에서 다른 정점으로 가는 최단 경로를 구하는 알고리즘

  1. 각 정점 위에 시작점으로부터 자신에게 이르는 경로의 길이를 저장할 곳을 정의하고 모든 정점 위에 있는 경로의 길이를 무한대로 초기화한다.
  2. 시작 정점의 길이를 0으로 초기화하고 최단 경로에 추가한다.
  3. 최단 경로에 새로 추가된 정점의 인접 정점들에 대해 경로 길이를 갱신하고 이들을 최단 경로에 추가한다. 만약 추가하려는 인접 정점이 이미 최단 경로위에 있는 정점이라면 갱신하려는 경로의 길이가 더 짧은 경우에만 기존의 경로를 현재 정점을 경유하도록 수정한다.
  4. 그래프 내의 모든 정점이 최단 경로에 속할 때까지 3번을 반복한다.

  탐욕법이 활용되는 부분은 1,2번이 알고리즘의 초기화 단계

  3단계는 해 선택과 적절성 검사, 4단계는 해 검사이다.

  

